{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Football Pipeline Docs","text":"<p> Please note that this is as work in progress documentation.</p>"},{"location":"#football-project","title":"FOOTBALL PROJECT","text":""},{"location":"#project-description","title":"Project Description","text":"<p>This project serves as a portfolio to demonstrate data engineering skills, covering the complete data lifecycle: extraction, ingestion, transformation, orchestration, storage, visualization, and governance. It leverages modern technologies and industry best practices, including Docker, Airflow, Python with Poetry, PostgreSQL, dbt, Streamlit, MinIO (not yet), MkDocs, Logfire, and OpenLineage.</p> <p>Note: Focused on prototyping various tools to understand their usage, not on building the best and fastest processes.</p>"},{"location":"#general-workflow","title":"General Workflow","text":""},{"location":"#overall-architecture","title":"Overall Architecture","text":"<ol> <li> <p>Data Source: https://www.football-data.org/</p> </li> <li> <p>Data Ingestion:    Fetch data from a public football API and store it in a PostgreSQL database. API Extraction Code Docs</p> </li> <li> <p>Data Transformation:    Process the data using Python and dbt to organize the Data Warehouse layers (staging, intermediate, mart).</p> </li> <li> <p>Orchestration:    Use Airflow to manage the data pipeline. Airflow will invoke custom Docker images to process the data.    Note: We use the Astronomer version for simplicity; download it to streamline the process.    Note2: In the airflow settings file configured by Astronomer, include your API key and PostgreSQL settings in the <code>airflow_settings.yaml</code> file: <pre><code>variables:\n - variable_name: API_KEY\n   variable_value: &lt;YOUR API KEY&gt;\n</code></pre>    A sample file was added: <code>sample_airflow_settings.yml</code>    Info: I've Changed Astro PostgreSQL port: <code>astro config set postgres.port 5435</code>    There is also an <code>sample.env</code> that needs to be configured with the token for logfire.</p> </li> <li> <p>Governance and Quality:  </p> </li> <li>Open Metadata as a data catalog and data governance tool, with the aditional data quality integrations. (Not ready)</li> <li> <p>For Data Quality apply data contracts with pydantic.</p> </li> <li> <p>Visualization and Reporting:    Create interactive dashboards with Streamlit and export reports to MinIO.</p> </li> <li> <p>Documentation:    Use MkDocs with the Material for MkDocs theme to document the project, including technical details, architecture, and usage instructions.</p> </li> <li> <p>Observability:    Use Logfire as an observability tool to monitor the environment.</p> </li> </ol>"},{"location":"#technologies-used","title":"Technologies Used","text":"<ul> <li>Orchestration: Apache Airflow  </li> <li>Processing: Python (with Poetry, Pydantic)  </li> <li>Transformation: dbt (Data Build Tool)  </li> <li>Database: PostgreSQL  </li> <li>Visualization: Streamlit  </li> <li>Report Storage: MinIO (S3 simulation)</li> <li>Containerization: Docker and Docker Compose  </li> <li>Data Validation: TBD  </li> <li>Data Lineage: OpenLineage integrated with Airflow  </li> <li>Documentation: MkDocs (Material for MkDocs)  </li> <li>Observability: Logfire</li> </ul>"},{"location":"#how-to-run","title":"How to Run","text":""},{"location":"#pre-requisites","title":"Pre-requisites","text":"<ol> <li>Docker</li> <li>Python <code>3.12.15</code></li> <li>Poetry</li> <li>Astro CLI</li> <li>Postgres Database - I choose to create one using Render for Free that would be easier to connect and to handle.</li> <li>Logfire Account</li> </ol>"},{"location":"#running-steps-mac-os","title":"Running Steps (Mac Os)","text":"<p>Note: before anything else, update all <code>.env</code> files.    a. on root folder <code>./</code>    b. on airflow folder <code>docker/airflow/</code> (<code>.env</code> and <code>airflow_settings.yaml</code>)</p>"},{"location":"#starting-the-environment","title":"Starting the Environment","text":"<p>Open terminal on the root folder of the project and type: 1. <code>poetry shell &amp;&amp; poetry install</code> - To open the poetry virtual env and install all library dependencies 2. <code>task build_docker_images</code> - To generate the python code images 3. <code>task start airflow</code> - To start airflow    a. <code>task restart_airflow</code> - To restart airflow if needed    b. <code>task stop_airflow</code> - To stop airflow if needed 4. <code>task run_marquez</code> - This can be run in a different terminal window because it will keep running. It will start the marquez server to track the lineage for DataOps reasons.</p> <p>Once the entire environment is up you can access using the browser: 1. Airflow: Airflow UI - Monitoring and running the orchestration 2. Marquez: Marquez UI - Monitoring the data lineage 3. Logfire: Logfire UI - Monitoring the pipeline healthy</p> <p>Starting the process: 1. In airflow UI you need to turn the dag into active mode and this will automatically trigger the entire end-to-end process. DAG: <code>football_pipeline_with_lineage</code></p> <p>Once it end successfully, you can use streamlit to visualize the data. On Terminal, root folder: 1. <code>task run_streamlit</code> - To generate the server 2. Navigate to Streamlit UI</p>"},{"location":"#useful-info","title":"Useful Info","text":"<ol> <li>To export the .env variables to your local poetry env and do local testing - On terminal: <pre><code>export $(cat .env | xargs)\n</code></pre> This is useful for DBT checks.</li> <li>To check project python code documentation locally: First on terminal: <pre><code>mkdocs serve\n</code></pre> then MkDocs UI</li> </ol>"},{"location":"#directory-structure","title":"Directory Structure","text":"<pre><code>project/                   \n\u251c\u2500\u2500 docker/                   # Dockerfiles for different components\n\u2502   \u251c\u2500\u2500 airflow/              # Airflow Configs\n\u2502   \u2502   \u251c\u2500\u2500 dags/             # Airflow DAGs\n\u2502   \u2502   \u251c\u2500\u2500 dbt/              # DBT folder\n|   \u2502   \u2502   \u251c\u2500\u2500 dbt_football/ # DBT configs and models\n\u2502   \u251c\u2500\u2500 streamlit/            # Dockerfile do streamlit\n\u2502   \u251c\u2500\u2500 python/               # Python code Dockerfile \n\u2502   \u251c\u2500\u2500 marquez/              # Marquez Dockerfiles\n\u251c\u2500\u2500 docs/                     # Documentation Files (MkDocs)\n\u251c\u2500\u2500 images/                   # README Images\n\u251c\u2500\u2500 src/                      # Python Source Code\n\u2502   \u251c\u2500\u2500 contracts/            # Data Contracts\n\u2502   \u251c\u2500\u2500 utils/                # Python utilities and libraries\n\u2502   \u251c\u2500\u2500 visualization/        # Streamlit Code\n\u2502   \u251c\u2500\u2500 main.py               # Python main code\n\u251c\u2500\u2500 tests/                    # Automated tests (pytest)\n\u251c\u2500\u2500 .env                      # Environment Variables\n\u251c\u2500\u2500 pytest.ini                # Minor Pytest configurations\n\u251c\u2500\u2500 mkdocs.yml                # MKdocs Config\n\u251c\u2500\u2500 README.md                 # Readme File\n\u251c\u2500\u2500 poetry.lock               # Poetry lock\n\u2514\u2500\u2500 pyproject.toml            # Poetry Config\n</code></pre>"},{"location":"#workflow-images","title":"Workflow Images:","text":"<p>Orchestrator</p> <p></p> <p>Data Quality - Open AI</p> <p> </p> <p>Data Visualization Streamlit</p> <p> </p> <p>Data Ops - Open Lineage</p> <p></p> <p>Observability</p> <p></p>"},{"location":"#known-issues","title":"Known Issues:","text":"<ol> <li>There are issues with group stage competitions that needs further investigation.</li> <li>See all upcoming matches for Real Madrid: -- API blocked the access at this endpoint. To be further investigated. https://api.football-data.org/v4/teams/86/matches?status=SCHEDULED</li> </ol>"},{"location":"#next-steps","title":"Next Steps","text":"<p>~~0. Refactor README and document python code with docstrings and mkdocs.~~</p> <ol> <li>Implement data catalog with Open Metadata:    a. Lineage can be added there and marquez can be removed.    b. Some Data Quality can be implemented in a centralized place with Open Metadata.</li> <li>Integrate airflow with Minio to export reports to an like S3 bucket.</li> <li>Fix known issues with the cup competitions that have group stages and affect the process and the visualization. Known Issue #1</li> <li>Investigate known issue #2.</li> <li>Add more gen AI features    a. Create tab In Streamlit App with OpenAI to answer questions regarding the data.  </li> </ol>"},{"location":"extraction/competitions_api/","title":"Competitions","text":""},{"location":"extraction/competitions_api/#workflow-processor-api","title":"Workflow (Processor + API)","text":"<pre><code>graph TD;\n    A[Start Processing] --&gt; B[CompetitionsProcessor Process];\n    B --&gt; C[CompetitionsAPI get_competitions];\n    C --&gt; D[Get Competitions Data];\n    D --&gt; E[Transform Data];\n    E --&gt; F[Add Metadata];\n    A --&gt; G[CompetitionDetailsProcessor Process];\n    G --&gt; C\n    D --&gt; I[Transform Details];\n    I --&gt; J[Add Metadata];\n    F --&gt; K[Write to Database]\n    K --&gt; L[End];\n\n    subgraph API Calls\n        C\n    end\n\n    subgraph Competitions Processing\n        B --&gt; E\n        E --&gt; F\n    end\n\n    subgraph CompetitionDetails Processing\n        G --&gt; I\n        I --&gt; J\n    end\n\n    subgraph Database Operations\n        J --&gt; K\n    end\n</code></pre> CompetitionsAPI Class <p>               Bases: <code>FootballAPIBase</code></p> <p>Handles API interactions for retrieving football competition data.</p> <p>This class provides methods to fetch various data related to football competitions,  such as competition details, matches, standings, and top scorers.</p> <p>Methods:</p> Name Description <code>get_competitions</code> <p>Retrieves all available competitions based on a specified plan.</p> <code>get_competition_by_id</code> <p>Retrieves details for a specific competition by its ID.</p> <code>get_matches</code> <p>Retrieves all matches for a specific competition.</p> <code>get_standings</code> <p>Retrieves the standings for a specific competition and season.</p> <code>get_top_scorers</code> <p>Retrieves the top scorers for a specific competition and season.</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>class CompetitionsAPI(FootballAPIBase):\n    \"\"\"\n    Handles API interactions for retrieving football competition data.\n\n    This class provides methods to fetch various data related to football competitions, \n    such as competition details, matches, standings, and top scorers.\n\n    Methods:\n        get_competitions: Retrieves all available competitions based on a specified plan.\n        get_competition_by_id: Retrieves details for a specific competition by its ID.\n        get_matches: Retrieves all matches for a specific competition.\n        get_standings: Retrieves the standings for a specific competition and season.\n        get_top_scorers: Retrieves the top scorers for a specific competition and season.\n    \"\"\"\n    def get_competitions(self, plan: str = \"TIER_ONE\") -&gt; Dict[str, Any]:\n        \"\"\"\n        Retrieves all available competitions based on the specified plan.\n\n        Args:\n            plan (str): Competition tier (e.g., TIER_ONE, TIER_TWO).\n\n        Returns:\n            Dict[str, Any]: A dictionary containing competition data.\n        \"\"\"\n        return self._make_request(\"competitions\", params={\"plan\": plan})\n\n    def get_competition_by_id(self, competition_id: int) -&gt; Dict[str, Any]:\n        \"\"\"\n        Retrieves details for a specific competition.\n\n        Args:\n            competition_id (int): The unique ID of the competition.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing the competition details.\n        \"\"\"\n        return self._make_request(f\"competitions/{competition_id}\")\n\n    def get_matches(self, competition_id: int) -&gt; Dict[str, Any]:\n        \"\"\"\n        Retrieves all matches for a specific competition.\n\n        Args:\n            competition_id (int): The unique ID of the competition.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing match data.\n        \"\"\"\n        return self._make_paginated_request(f\"competitions/{competition_id}/matches\")\n\n    def get_standings(self, competition_id: int, season: int = None) -&gt; Dict[str, Any]:\n        \"\"\"\n        Retrieves the standings for a specific competition.\n\n        Args:\n            competition_id (int): The unique ID of the competition.\n            season (int, optional): The season for which the standings are to be retrieved. If None, the current season is used.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing the standings data.\n        \"\"\"\n        if not season:\n            return self._make_request(f\"competitions/{competition_id}/standings\")\n        else:    \n            return self._make_request(f\"competitions/{competition_id}/standings?season={season}\")\n\n    def get_top_scorers(self, competition_id: int, season: int = None) -&gt; Dict[str, Any]:\n        \"\"\"\n        Retrieves top scorers for a specific competition.\n\n        Args:\n            competition_id (int): The unique ID of the competition.\n            season (int, optional): The season for which the top scorers are to be retrieved. If None, the current season is used.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing top scorers data.\n        \"\"\"\n        if not season:\n            return self._make_request(f\"competitions/{competition_id}/scorers\")\n        else:    \n            return self._make_request(f\"competitions/{competition_id}/scorers?season={season}\")\n</code></pre> CompetitionsProcessor Class <p>               Bases: <code>Processor</code></p> <p>Processes competition data fetched from the API and stores it in a database.</p> <p>This class is responsible for processing competition data by fetching it from the API, transforming the data (e.g., converting to DataFrames), and loading it into a PostgreSQL database.</p> <p>Attributes:</p> Name Type Description <code>schema</code> <code>str</code> <p>The database schema where data will be stored. Default is 'RAW'.</p> <code>table</code> <code>str</code> <p>The database table where data will be written. Default is None.</p> <p>Methods:</p> Name Description <code>process</code> <p>Main method to fetch, transform, and load competition data.</p> <code>_write_to_db</code> <p>Writes the processed DataFrame to the specified database table.</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>class CompetitionsProcessor(Processor):\n    \"\"\"\n    Processes competition data fetched from the API and stores it in a database.\n\n    This class is responsible for processing competition data by fetching it from the API,\n    transforming the data (e.g., converting to DataFrames), and loading it into a PostgreSQL database.\n\n    Attributes:\n        schema (str): The database schema where data will be stored. Default is 'RAW'.\n        table (str): The database table where data will be written. Default is None.\n\n    Methods:\n        process: Main method to fetch, transform, and load competition data.\n        _write_to_db: Writes the processed DataFrame to the specified database table.\n    \"\"\"\n    def __init__(self, api_connection: CompetitionsAPI, schema = 'RAW', table = None):\n        \"\"\"\n        Initializes the CompetitionsProcessor with the API connection and database details.\n\n        Args:\n            api_connection (CompetitionsAPI): The API connection instance for fetching competition data.\n            schema (str, optional): The database schema for storing the data. Default is 'RAW'.\n            table (str, optional): The target database table. Default is None.\n        \"\"\"\n        super().__init__(api_connection, self.__class__.__name__)\n\n        if schema:\n            self.schema = schema\n        if table:\n            self.table = table\n\n        self.db = Database(\n            db_name=os.getenv('PG_DB'),\n            user=os.getenv('PG_USER'),\n            password=os.getenv('PG_PASS'),\n            host=os.getenv('PG_HOST'),\n            port=5432\n        )\n\n    def process(self) -&gt; None:\n        \"\"\"\n        Processes competition data by fetching, transforming, and loading it into the database.\n\n        The method fetches data from the API, transforms it into a DataFrame, and writes the data \n        to the specified database table, adding a timestamp for tracking purposes.\n\n        Returns:\n            None\n        \"\"\"\n        self.logger.info(f\"Start Processing - {self.table}\")\n        self.logger.info(\"Dataframe from response:\")\n        competitions_data = CompetitionsResponse(**self.api_connection.get_competitions())\n\n        # Convertendo para dicion\u00e1rio e depois criando o DataFrame\n        competitions_dict = [comp.model_dump() for comp in competitions_data.competitions]\n        df = pd.DataFrame(competitions_dict)\n\n        # Converte as colunas 'area' e 'current_season' para JSON (se n\u00e3o forem nulas)\n        df['area'] = df['area'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        df['current_season'] = df['current_season'].apply(lambda x: json.dumps(x, default=str) if isinstance(x, dict) else None)\n\n        load_timesamp = datetime.datetime.now(datetime.timezone.utc).isoformat() \n\n        metadata = {\n            \"load_timestamp\": [load_timesamp] * len(df),\n        }\n\n        metadata_df = pd.DataFrame(metadata)\n\n        df_with_metadata = pd.concat([df, metadata_df], axis=1)\n\n        # Verificando o DataFrame\n        self.logger.info(df_with_metadata)\n        self.logger.info(f\"Writing to Database - {self.table}:\")\n        self._write_to_db(df_with_metadata)\n\n    def _write_to_db(self, df: pd.DataFrame) -&gt; None:\n        \"\"\"\n        Writes the processed DataFrame to the specified database table.\n\n        Args:\n            df (pd.DataFrame): The processed DataFrame to be inserted into the database.\n\n        Returns:\n            None\n        \"\"\"\n        query = getattr(create_queries, self.table.upper()).format(\n            schema=self.schema,\n            table=self.table\n        )\n        # Verificar e criar a tabela se necess\u00e1rio\n        self.db.validate_table_exists(self.schema, self.table, query)\n        self.db.execute_query(\n            create_queries.TRUNCATE_TABLE.format(\n                schema=self.schema,\n                table=self.table\n            )\n        )\n        self.db.insert_pandas_bulk(df,f'{self.schema}.{self.table}')\n</code></pre> CompetitionsDetailsProcessor Class <p>               Bases: <code>Processor</code></p> <p>Processes competition data fetched from the API and stores it in a database.</p> <p>This class is responsible for processing competition data by fetching it from the API, transforming the data (e.g., converting to DataFrames), and loading it into a PostgreSQL database.</p> <p>Attributes:</p> Name Type Description <code>schema</code> <code>str</code> <p>The database schema where data will be stored. Default is 'RAW'.</p> <code>table</code> <code>str</code> <p>The database table where data will be written. Default is None.</p> <p>Methods:</p> Name Description <code>process</code> <p>Main method to fetch, transform, and load competition data.</p> <code>_write_to_db</code> <p>Writes the processed DataFrame to the specified database table.</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>class CompetitionsProcessor(Processor):\n    \"\"\"\n    Processes competition data fetched from the API and stores it in a database.\n\n    This class is responsible for processing competition data by fetching it from the API,\n    transforming the data (e.g., converting to DataFrames), and loading it into a PostgreSQL database.\n\n    Attributes:\n        schema (str): The database schema where data will be stored. Default is 'RAW'.\n        table (str): The database table where data will be written. Default is None.\n\n    Methods:\n        process: Main method to fetch, transform, and load competition data.\n        _write_to_db: Writes the processed DataFrame to the specified database table.\n    \"\"\"\n    def __init__(self, api_connection: CompetitionsAPI, schema = 'RAW', table = None):\n        \"\"\"\n        Initializes the CompetitionsProcessor with the API connection and database details.\n\n        Args:\n            api_connection (CompetitionsAPI): The API connection instance for fetching competition data.\n            schema (str, optional): The database schema for storing the data. Default is 'RAW'.\n            table (str, optional): The target database table. Default is None.\n        \"\"\"\n        super().__init__(api_connection, self.__class__.__name__)\n\n        if schema:\n            self.schema = schema\n        if table:\n            self.table = table\n\n        self.db = Database(\n            db_name=os.getenv('PG_DB'),\n            user=os.getenv('PG_USER'),\n            password=os.getenv('PG_PASS'),\n            host=os.getenv('PG_HOST'),\n            port=5432\n        )\n\n    def process(self) -&gt; None:\n        \"\"\"\n        Processes competition data by fetching, transforming, and loading it into the database.\n\n        The method fetches data from the API, transforms it into a DataFrame, and writes the data \n        to the specified database table, adding a timestamp for tracking purposes.\n\n        Returns:\n            None\n        \"\"\"\n        self.logger.info(f\"Start Processing - {self.table}\")\n        self.logger.info(\"Dataframe from response:\")\n        competitions_data = CompetitionsResponse(**self.api_connection.get_competitions())\n\n        # Convertendo para dicion\u00e1rio e depois criando o DataFrame\n        competitions_dict = [comp.model_dump() for comp in competitions_data.competitions]\n        df = pd.DataFrame(competitions_dict)\n\n        # Converte as colunas 'area' e 'current_season' para JSON (se n\u00e3o forem nulas)\n        df['area'] = df['area'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        df['current_season'] = df['current_season'].apply(lambda x: json.dumps(x, default=str) if isinstance(x, dict) else None)\n\n        load_timesamp = datetime.datetime.now(datetime.timezone.utc).isoformat() \n\n        metadata = {\n            \"load_timestamp\": [load_timesamp] * len(df),\n        }\n\n        metadata_df = pd.DataFrame(metadata)\n\n        df_with_metadata = pd.concat([df, metadata_df], axis=1)\n\n        # Verificando o DataFrame\n        self.logger.info(df_with_metadata)\n        self.logger.info(f\"Writing to Database - {self.table}:\")\n        self._write_to_db(df_with_metadata)\n\n    def _write_to_db(self, df: pd.DataFrame) -&gt; None:\n        \"\"\"\n        Writes the processed DataFrame to the specified database table.\n\n        Args:\n            df (pd.DataFrame): The processed DataFrame to be inserted into the database.\n\n        Returns:\n            None\n        \"\"\"\n        query = getattr(create_queries, self.table.upper()).format(\n            schema=self.schema,\n            table=self.table\n        )\n        # Verificar e criar a tabela se necess\u00e1rio\n        self.db.validate_table_exists(self.schema, self.table, query)\n        self.db.execute_query(\n            create_queries.TRUNCATE_TABLE.format(\n                schema=self.schema,\n                table=self.table\n            )\n        )\n        self.db.insert_pandas_bulk(df,f'{self.schema}.{self.table}')\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsAPI.get_competitions","title":"<code>get_competitions(plan='TIER_ONE')</code>","text":"<p>Retrieves all available competitions based on the specified plan.</p> <p>Parameters:</p> Name Type Description Default <code>plan</code> <code>str</code> <p>Competition tier (e.g., TIER_ONE, TIER_TWO).</p> <code>'TIER_ONE'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing competition data.</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def get_competitions(self, plan: str = \"TIER_ONE\") -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieves all available competitions based on the specified plan.\n\n    Args:\n        plan (str): Competition tier (e.g., TIER_ONE, TIER_TWO).\n\n    Returns:\n        Dict[str, Any]: A dictionary containing competition data.\n    \"\"\"\n    return self._make_request(\"competitions\", params={\"plan\": plan})\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsAPI.get_competition_by_id","title":"<code>get_competition_by_id(competition_id)</code>","text":"<p>Retrieves details for a specific competition.</p> <p>Parameters:</p> Name Type Description Default <code>competition_id</code> <code>int</code> <p>The unique ID of the competition.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing the competition details.</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def get_competition_by_id(self, competition_id: int) -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieves details for a specific competition.\n\n    Args:\n        competition_id (int): The unique ID of the competition.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing the competition details.\n    \"\"\"\n    return self._make_request(f\"competitions/{competition_id}\")\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsAPI.get_matches","title":"<code>get_matches(competition_id)</code>","text":"<p>Retrieves all matches for a specific competition.</p> <p>Parameters:</p> Name Type Description Default <code>competition_id</code> <code>int</code> <p>The unique ID of the competition.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing match data.</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def get_matches(self, competition_id: int) -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieves all matches for a specific competition.\n\n    Args:\n        competition_id (int): The unique ID of the competition.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing match data.\n    \"\"\"\n    return self._make_paginated_request(f\"competitions/{competition_id}/matches\")\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsAPI.get_standings","title":"<code>get_standings(competition_id, season=None)</code>","text":"<p>Retrieves the standings for a specific competition.</p> <p>Parameters:</p> Name Type Description Default <code>competition_id</code> <code>int</code> <p>The unique ID of the competition.</p> required <code>season</code> <code>int</code> <p>The season for which the standings are to be retrieved. If None, the current season is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing the standings data.</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def get_standings(self, competition_id: int, season: int = None) -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieves the standings for a specific competition.\n\n    Args:\n        competition_id (int): The unique ID of the competition.\n        season (int, optional): The season for which the standings are to be retrieved. If None, the current season is used.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing the standings data.\n    \"\"\"\n    if not season:\n        return self._make_request(f\"competitions/{competition_id}/standings\")\n    else:    \n        return self._make_request(f\"competitions/{competition_id}/standings?season={season}\")\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsAPI.get_top_scorers","title":"<code>get_top_scorers(competition_id, season=None)</code>","text":"<p>Retrieves top scorers for a specific competition.</p> <p>Parameters:</p> Name Type Description Default <code>competition_id</code> <code>int</code> <p>The unique ID of the competition.</p> required <code>season</code> <code>int</code> <p>The season for which the top scorers are to be retrieved. If None, the current season is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing top scorers data.</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def get_top_scorers(self, competition_id: int, season: int = None) -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieves top scorers for a specific competition.\n\n    Args:\n        competition_id (int): The unique ID of the competition.\n        season (int, optional): The season for which the top scorers are to be retrieved. If None, the current season is used.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing top scorers data.\n    \"\"\"\n    if not season:\n        return self._make_request(f\"competitions/{competition_id}/scorers\")\n    else:    \n        return self._make_request(f\"competitions/{competition_id}/scorers?season={season}\")\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsProcessor.__init__","title":"<code>__init__(api_connection, schema='RAW', table=None)</code>","text":"<p>Initializes the CompetitionsProcessor with the API connection and database details.</p> <p>Parameters:</p> Name Type Description Default <code>api_connection</code> <code>CompetitionsAPI</code> <p>The API connection instance for fetching competition data.</p> required <code>schema</code> <code>str</code> <p>The database schema for storing the data. Default is 'RAW'.</p> <code>'RAW'</code> <code>table</code> <code>str</code> <p>The target database table. Default is None.</p> <code>None</code> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def __init__(self, api_connection: CompetitionsAPI, schema = 'RAW', table = None):\n    \"\"\"\n    Initializes the CompetitionsProcessor with the API connection and database details.\n\n    Args:\n        api_connection (CompetitionsAPI): The API connection instance for fetching competition data.\n        schema (str, optional): The database schema for storing the data. Default is 'RAW'.\n        table (str, optional): The target database table. Default is None.\n    \"\"\"\n    super().__init__(api_connection, self.__class__.__name__)\n\n    if schema:\n        self.schema = schema\n    if table:\n        self.table = table\n\n    self.db = Database(\n        db_name=os.getenv('PG_DB'),\n        user=os.getenv('PG_USER'),\n        password=os.getenv('PG_PASS'),\n        host=os.getenv('PG_HOST'),\n        port=5432\n    )\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsProcessor.process","title":"<code>process()</code>","text":"<p>Processes competition data by fetching, transforming, and loading it into the database.</p> <p>The method fetches data from the API, transforms it into a DataFrame, and writes the data  to the specified database table, adding a timestamp for tracking purposes.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def process(self) -&gt; None:\n    \"\"\"\n    Processes competition data by fetching, transforming, and loading it into the database.\n\n    The method fetches data from the API, transforms it into a DataFrame, and writes the data \n    to the specified database table, adding a timestamp for tracking purposes.\n\n    Returns:\n        None\n    \"\"\"\n    self.logger.info(f\"Start Processing - {self.table}\")\n    self.logger.info(\"Dataframe from response:\")\n    competitions_data = CompetitionsResponse(**self.api_connection.get_competitions())\n\n    # Convertendo para dicion\u00e1rio e depois criando o DataFrame\n    competitions_dict = [comp.model_dump() for comp in competitions_data.competitions]\n    df = pd.DataFrame(competitions_dict)\n\n    # Converte as colunas 'area' e 'current_season' para JSON (se n\u00e3o forem nulas)\n    df['area'] = df['area'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    df['current_season'] = df['current_season'].apply(lambda x: json.dumps(x, default=str) if isinstance(x, dict) else None)\n\n    load_timesamp = datetime.datetime.now(datetime.timezone.utc).isoformat() \n\n    metadata = {\n        \"load_timestamp\": [load_timesamp] * len(df),\n    }\n\n    metadata_df = pd.DataFrame(metadata)\n\n    df_with_metadata = pd.concat([df, metadata_df], axis=1)\n\n    # Verificando o DataFrame\n    self.logger.info(df_with_metadata)\n    self.logger.info(f\"Writing to Database - {self.table}:\")\n    self._write_to_db(df_with_metadata)\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsProcessor._write_to_db","title":"<code>_write_to_db(df)</code>","text":"<p>Writes the processed DataFrame to the specified database table.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The processed DataFrame to be inserted into the database.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def _write_to_db(self, df: pd.DataFrame) -&gt; None:\n    \"\"\"\n    Writes the processed DataFrame to the specified database table.\n\n    Args:\n        df (pd.DataFrame): The processed DataFrame to be inserted into the database.\n\n    Returns:\n        None\n    \"\"\"\n    query = getattr(create_queries, self.table.upper()).format(\n        schema=self.schema,\n        table=self.table\n    )\n    # Verificar e criar a tabela se necess\u00e1rio\n    self.db.validate_table_exists(self.schema, self.table, query)\n    self.db.execute_query(\n        create_queries.TRUNCATE_TABLE.format(\n            schema=self.schema,\n            table=self.table\n        )\n    )\n    self.db.insert_pandas_bulk(df,f'{self.schema}.{self.table}')\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsProcessor.__init__","title":"<code>__init__(api_connection, schema='RAW', table=None)</code>","text":"<p>Initializes the CompetitionsProcessor with the API connection and database details.</p> <p>Parameters:</p> Name Type Description Default <code>api_connection</code> <code>CompetitionsAPI</code> <p>The API connection instance for fetching competition data.</p> required <code>schema</code> <code>str</code> <p>The database schema for storing the data. Default is 'RAW'.</p> <code>'RAW'</code> <code>table</code> <code>str</code> <p>The target database table. Default is None.</p> <code>None</code> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def __init__(self, api_connection: CompetitionsAPI, schema = 'RAW', table = None):\n    \"\"\"\n    Initializes the CompetitionsProcessor with the API connection and database details.\n\n    Args:\n        api_connection (CompetitionsAPI): The API connection instance for fetching competition data.\n        schema (str, optional): The database schema for storing the data. Default is 'RAW'.\n        table (str, optional): The target database table. Default is None.\n    \"\"\"\n    super().__init__(api_connection, self.__class__.__name__)\n\n    if schema:\n        self.schema = schema\n    if table:\n        self.table = table\n\n    self.db = Database(\n        db_name=os.getenv('PG_DB'),\n        user=os.getenv('PG_USER'),\n        password=os.getenv('PG_PASS'),\n        host=os.getenv('PG_HOST'),\n        port=5432\n    )\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsProcessor.process","title":"<code>process()</code>","text":"<p>Processes competition data by fetching, transforming, and loading it into the database.</p> <p>The method fetches data from the API, transforms it into a DataFrame, and writes the data  to the specified database table, adding a timestamp for tracking purposes.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def process(self) -&gt; None:\n    \"\"\"\n    Processes competition data by fetching, transforming, and loading it into the database.\n\n    The method fetches data from the API, transforms it into a DataFrame, and writes the data \n    to the specified database table, adding a timestamp for tracking purposes.\n\n    Returns:\n        None\n    \"\"\"\n    self.logger.info(f\"Start Processing - {self.table}\")\n    self.logger.info(\"Dataframe from response:\")\n    competitions_data = CompetitionsResponse(**self.api_connection.get_competitions())\n\n    # Convertendo para dicion\u00e1rio e depois criando o DataFrame\n    competitions_dict = [comp.model_dump() for comp in competitions_data.competitions]\n    df = pd.DataFrame(competitions_dict)\n\n    # Converte as colunas 'area' e 'current_season' para JSON (se n\u00e3o forem nulas)\n    df['area'] = df['area'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    df['current_season'] = df['current_season'].apply(lambda x: json.dumps(x, default=str) if isinstance(x, dict) else None)\n\n    load_timesamp = datetime.datetime.now(datetime.timezone.utc).isoformat() \n\n    metadata = {\n        \"load_timestamp\": [load_timesamp] * len(df),\n    }\n\n    metadata_df = pd.DataFrame(metadata)\n\n    df_with_metadata = pd.concat([df, metadata_df], axis=1)\n\n    # Verificando o DataFrame\n    self.logger.info(df_with_metadata)\n    self.logger.info(f\"Writing to Database - {self.table}:\")\n    self._write_to_db(df_with_metadata)\n</code></pre>"},{"location":"extraction/competitions_api/#src.utils.competitions_api.CompetitionsProcessor._write_to_db","title":"<code>_write_to_db(df)</code>","text":"<p>Writes the processed DataFrame to the specified database table.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The processed DataFrame to be inserted into the database.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/utils/competitions_api.py</code> <pre><code>def _write_to_db(self, df: pd.DataFrame) -&gt; None:\n    \"\"\"\n    Writes the processed DataFrame to the specified database table.\n\n    Args:\n        df (pd.DataFrame): The processed DataFrame to be inserted into the database.\n\n    Returns:\n        None\n    \"\"\"\n    query = getattr(create_queries, self.table.upper()).format(\n        schema=self.schema,\n        table=self.table\n    )\n    # Verificar e criar a tabela se necess\u00e1rio\n    self.db.validate_table_exists(self.schema, self.table, query)\n    self.db.execute_query(\n        create_queries.TRUNCATE_TABLE.format(\n            schema=self.schema,\n            table=self.table\n        )\n    )\n    self.db.insert_pandas_bulk(df,f'{self.schema}.{self.table}')\n</code></pre>"},{"location":"extraction/competitions_api/#queries","title":"Queries","text":"Create Queries - Schema <pre><code>COMPETITIONS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    area JSONB NOT NULL,\n    code VARCHAR(50),\n    type VARCHAR(50),\n    emblem VARCHAR(255),\n    plan VARCHAR(50),\n    current_season JSONB NOT NULL,\n    number_of_available_seasons INT NOT NULL,\n    last_updated TIMESTAMP NOT NULL,\n    load_timestamp TIMESTAMP NOT NULL\n);\n\"\"\"\n\nTEAMS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    area JSONB NOT NULL,\n    competition_id INTEGER NOT NULL,\n    team_id INTEGER NOT NULL,\n    name VARCHAR(255) NOT NULL,\n    short_name VARCHAR(255),\n    tla VARCHAR(255) NOT NULL,\n    crest VARCHAR(255) NOT NULL,\n    address VARCHAR(255) NOT NULL,\n    website VARCHAR(255),\n    founded FLOAT,\n    club_colors VARCHAR(255),\n    venue VARCHAR(255),\n    running_competitions JSONB,\n    coach JSONB,\n    squad JSONB,\n    staff JSONB,\n    last_updated TIMESTAMP NOT NULL,\n    load_timestamp TIMESTAMP NOT NULL,\n    UNIQUE (competition_id, team_id)\n);\n\"\"\"\n\nCOMPETITIONS_STANDINGS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    position INTEGER NOT NULL,\n    team JSONB NOT NULL,\n    played_games INTEGER NOT NULL,\n    form VARCHAR(255),\n    won INTEGER NOT NULL,\n    draw INTEGER NOT NULL,\n    lost INTEGER NOT NULL,\n    points INTEGER NOT NULL,\n    goals_for INTEGER NOT NULL,\n    goals_against INTEGER NOT NULL,\n    goal_difference INTEGER NOT NULL,\n    competition_id INTEGER NOT NULL,\n    season INTEGER NOT NULL,\n    season_info JSONB,\n    load_timestamp TIMESTAMP NOT NULL,\n    UNIQUE (competition_id, position, season)\n);\n\"\"\"\n\nCOMPETITIONS_TOP_SCORERS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    player JSONB NOT NULL,                \n    team JSONB NOT NULL,                   \n    played_matches INT,                   \n    goals INT,                            \n    assists FLOAT,                          \n    penalties FLOAT,                      \n    competition_id INT NOT NULL,          \n    season INT NOT NULL,                  \n    season_info JSONB NOT NULL,            \n    load_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,\n    UNIQUE (competition_id, season, player)\n);\n\"\"\"\n\nMATCHES_TODAY = \"\"\"\nCREATE TABLE {schema}.{table} (\n    area JSONB, \n    competition JSONB, \n    season JSONB, \n    id BIGINT PRIMARY KEY,\n    utc_date TIMESTAMP WITH TIME ZONE,\n    status VARCHAR(50),\n    matchday INT, \n    stage VARCHAR(50),\n    which_group VARCHAR(50), \n    last_updated TIMESTAMP WITH TIME ZONE,\n    home_team JSONB, \n    away_team JSONB, \n    score JSONB, \n    odds JSONB,\n    referees JSONB, \n    date_from DATE,\n    load_timestamp TIMESTAMP WITH TIME ZONE\n);\n\"\"\"\n\nTEAMS_UPCOMING_MATCHES = \"\"\"\nCREATE TABLE {schema}.{table} (\n    area JSONB, \n    competition JSONB, \n    season JSONB, \n    id BIGINT PRIMARY KEY,\n    utc_date TIMESTAMP WITH TIME ZONE,\n    status VARCHAR(50),\n    matchday INT, \n    stage VARCHAR(50),\n    which_group VARCHAR(50), \n    last_updated TIMESTAMP WITH TIME ZONE,\n    home_team JSONB, \n    away_team JSONB, \n    score JSONB, \n    odds JSONB,\n    referees JSONB, \n    date_from DATE,\n    date_to DATE,\n    load_timestamp TIMESTAMP WITH TIME ZONE\n);\n\"\"\"\n\nTRUNCATE_TABLE = \"\"\"\ntruncate table {schema}.{table};\n\"\"\"\n</code></pre>"},{"location":"extraction/matches_api/","title":"Matches","text":""},{"location":"extraction/matches_api/#workflow-processor-api","title":"Workflow (Processor + API)","text":"<pre><code>graph TD\n    A[Start] --&gt; K[Processor]\n    K --&gt; B[MatchesProcessor]\n    B --&gt; C[Matches API]\n    C --&gt; D[API Request: Get Matches Today]\n    D --&gt; E[Matches Data Retrieved]\n    E --&gt; F[Convert to DataFrame]\n    F --&gt; G[Transform Data -JSON Columns-]\n    G --&gt; H[Add Load Timestamp]\n    H --&gt; I[Load Data to DB]\n    I --&gt; J[Database Write]\n\n    C --&gt; Q[Logging]\n</code></pre> MatchesAPI Class <p>               Bases: <code>FootballAPIBase</code></p> <p>Handles API interactions for fetching team-related data.</p> <p>Methods:</p> Name Description <code>- get_matches_today</code> <p>Fetches all the matches that will happen today.</p> Source code in <code>src/utils/matches_api.py</code> <pre><code>class MatchesAPI(FootballAPIBase):\n    \"\"\"\n    Handles API interactions for fetching team-related data.\n\n    Methods:\n        - get_matches_today: Fetches all the matches that will happen today.\n    \"\"\"\n    def get_matches_today(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Retrieves all matches for your competition tier today.\n\n        Fetches match data from the football API and returns it in a dictionary format.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing match data, with details of matches scheduled for today.\n\n        Example:\n            {\n                \"matches\": [\n                    {\"match_id\": 123, \"home_team\": \"Team A\", \"away_team\": \"Team B\", ...},\n                    {\"match_id\": 124, \"home_team\": \"Team C\", \"away_team\": \"Team D\", ...}\n                ]\n            }\n        \"\"\"\n        return self._make_request(f\"matches\")\n</code></pre> MatchesProcessor Class <p>               Bases: <code>Processor</code></p> <p>Processes and integrates team data from the API into the database.</p> <p>Attributes:</p> Name Type Description <code>api_connection</code> <p>The API connection used for fetching data.</p> <code>schema</code> <code>str</code> <p>Database schema to use.</p> <code>table</code> <code>str</code> <p>Database table to insert data into.</p> <p>Methods:</p> Name Description <code>- process</code> <p>Fetches, transforms, and loads team data into the database.</p> Source code in <code>src/utils/matches_api.py</code> <pre><code>class MatchesProcessor(Processor):\n    \"\"\"\n    Processes and integrates team data from the API into the database.\n\n    Attributes:\n        api_connection: The API connection used for fetching data.\n        schema (str): Database schema to use.\n        table (str): Database table to insert data into.\n\n    Methods:\n        - process: Fetches, transforms, and loads team data into the database.\n    \"\"\"\n    def __init__(self, api_connection: MatchesAPI, schema = 'RAW', table = None):\n        \"\"\"\n        Initializes the MatchesProcessor.\n\n        Args:\n            api_connection: The API connection used for fetching data.\n            schema (str, optional): The schema to use in the database. Defaults to 'RAW'.\n            table (str, optional): The table to insert data into. Defaults to None.\n        \"\"\"\n        super().__init__(api_connection, self.__class__.__name__)\n\n        if schema:\n            self.schema = schema\n        if table:\n            self.table = table\n\n        self.db = Database(\n            db_name=os.getenv('PG_DB'),\n            user=os.getenv('PG_USER'),\n            password=os.getenv('PG_PASS'),\n            host=os.getenv('PG_HOST'),\n            port=5432\n        )\n\n    def process(self) -&gt; None:\n        \"\"\"\n        Processes team data by fetching it from the API, transforming it, \n        and loading it into the database.\n\n        This method fetches match data for today, transforms it into a DataFrame, \n        applies necessary transformations, and loads it into the specified database \n        table along with metadata like load timestamp.\n\n        The method performs the following steps:\n        - Fetches match data using the API.\n        - Converts the data into a pandas DataFrame.\n        - Transforms relevant columns into JSON format.\n        - Adds a load timestamp column.\n        - Loads the final DataFrame into the database.\n\n        Example:\n            matches_processor = MatchesProcessor(api_connection=matches_api, schema='RAW', table='matches')\n            matches_processor.process()\n        \"\"\"\n        self.logger.info(f\"Start Processing - {self.table}\")\n\n        matches_data = []\n\n        self.logger.info(f'Retrieving data for matches today.')\n        match_data = MatchesTodayResponse(**self.api_connection.get_matches_today())\n        # Convertendo para dicion\u00e1rio e depois criando o DataFrame\n        matches_dict = [comp.model_dump() for comp in match_data.matches]\n        df = pd.DataFrame(matches_dict)\n        df['date_from'] = match_data.filters.date_from\n\n        matches_data.append(df)\n\n        final_matches_df = pd.concat(matches_data)\n\n        # Converte as colunas 'area' e 'current_season' para JSON (se n\u00e3o forem nulas)\n        final_matches_df['area'] = final_matches_df['area'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_matches_df['competition'] = final_matches_df['competition'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_matches_df['season'] = final_matches_df['season'].apply(lambda x: json.dumps(x, default=str) if isinstance(x, dict) else None)\n        final_matches_df['home_team'] = final_matches_df['home_team'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_matches_df['away_team'] = final_matches_df['away_team'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_matches_df['score'] = final_matches_df['score'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_matches_df['odds'] = final_matches_df['odds'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_matches_df['referees'] = final_matches_df['referees'].apply(lambda x: json.dumps([element for element in x if isinstance(element, dict)], default=str) if isinstance(x, list) else None)\n\n        load_timesamp = datetime.datetime.now(datetime.timezone.utc).isoformat() \n\n        metadata = {\n            \"load_timestamp\": [load_timesamp] * len(final_matches_df),\n        }\n\n        metadata_df = pd.DataFrame(metadata, index=final_matches_df.index)\n\n        df_with_metadata = pd.concat([final_matches_df, metadata_df], axis=1)\n\n        # df_with_metadata.to_csv('matches_today', index=False)\n        self.logger.info(f\"Writing to Database - {self.table}:\")\n        self._write_to_db(df_with_metadata)\n\n    def _write_to_db(self, df: pd.DataFrame) -&gt; None:\n        \"\"\"\n        Writes the processed DataFrame to the database.\n\n        This method executes the necessary SQL queries to insert the data into the specified \n        database table after validating that the table exists and truncating the existing data.\n\n        Args:\n            df (pd.DataFrame): The DataFrame to write to the database.\n\n        Raises:\n            Exception: If there is an issue with the database connection or query execution.\n        \"\"\"\n\n        query = getattr(create_queries, self.table.upper()).format(\n            schema=self.schema,\n            table=self.table\n        )\n        # Verificar e criar a tabela se necess\u00e1rio\n        self.db.validate_table_exists(self.schema, self.table, query)\n        self.db.execute_query(\n            create_queries.TRUNCATE_TABLE.format(\n                schema=self.schema,\n                table=self.table\n            )\n        )\n        self.db.insert_pandas_bulk(df,f'{self.schema}.{self.table}')\n</code></pre>"},{"location":"extraction/matches_api/#src.utils.matches_api.MatchesAPI.get_matches_today","title":"<code>get_matches_today()</code>","text":"<p>Retrieves all matches for your competition tier today.</p> <p>Fetches match data from the football API and returns it in a dictionary format.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing match data, with details of matches scheduled for today.</p> Example <p>{     \"matches\": [         {\"match_id\": 123, \"home_team\": \"Team A\", \"away_team\": \"Team B\", ...},         {\"match_id\": 124, \"home_team\": \"Team C\", \"away_team\": \"Team D\", ...}     ] }</p> Source code in <code>src/utils/matches_api.py</code> <pre><code>def get_matches_today(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieves all matches for your competition tier today.\n\n    Fetches match data from the football API and returns it in a dictionary format.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing match data, with details of matches scheduled for today.\n\n    Example:\n        {\n            \"matches\": [\n                {\"match_id\": 123, \"home_team\": \"Team A\", \"away_team\": \"Team B\", ...},\n                {\"match_id\": 124, \"home_team\": \"Team C\", \"away_team\": \"Team D\", ...}\n            ]\n        }\n    \"\"\"\n    return self._make_request(f\"matches\")\n</code></pre>"},{"location":"extraction/matches_api/#src.utils.matches_api.MatchesProcessor.__init__","title":"<code>__init__(api_connection, schema='RAW', table=None)</code>","text":"<p>Initializes the MatchesProcessor.</p> <p>Parameters:</p> Name Type Description Default <code>api_connection</code> <code>MatchesAPI</code> <p>The API connection used for fetching data.</p> required <code>schema</code> <code>str</code> <p>The schema to use in the database. Defaults to 'RAW'.</p> <code>'RAW'</code> <code>table</code> <code>str</code> <p>The table to insert data into. Defaults to None.</p> <code>None</code> Source code in <code>src/utils/matches_api.py</code> <pre><code>def __init__(self, api_connection: MatchesAPI, schema = 'RAW', table = None):\n    \"\"\"\n    Initializes the MatchesProcessor.\n\n    Args:\n        api_connection: The API connection used for fetching data.\n        schema (str, optional): The schema to use in the database. Defaults to 'RAW'.\n        table (str, optional): The table to insert data into. Defaults to None.\n    \"\"\"\n    super().__init__(api_connection, self.__class__.__name__)\n\n    if schema:\n        self.schema = schema\n    if table:\n        self.table = table\n\n    self.db = Database(\n        db_name=os.getenv('PG_DB'),\n        user=os.getenv('PG_USER'),\n        password=os.getenv('PG_PASS'),\n        host=os.getenv('PG_HOST'),\n        port=5432\n    )\n</code></pre>"},{"location":"extraction/matches_api/#src.utils.matches_api.MatchesProcessor.process","title":"<code>process()</code>","text":"<p>Processes team data by fetching it from the API, transforming it,  and loading it into the database.</p> <p>This method fetches match data for today, transforms it into a DataFrame,  applies necessary transformations, and loads it into the specified database  table along with metadata like load timestamp.</p> <p>The method performs the following steps: - Fetches match data using the API. - Converts the data into a pandas DataFrame. - Transforms relevant columns into JSON format. - Adds a load timestamp column. - Loads the final DataFrame into the database.</p> Example <p>matches_processor = MatchesProcessor(api_connection=matches_api, schema='RAW', table='matches') matches_processor.process()</p> Source code in <code>src/utils/matches_api.py</code> <pre><code>def process(self) -&gt; None:\n    \"\"\"\n    Processes team data by fetching it from the API, transforming it, \n    and loading it into the database.\n\n    This method fetches match data for today, transforms it into a DataFrame, \n    applies necessary transformations, and loads it into the specified database \n    table along with metadata like load timestamp.\n\n    The method performs the following steps:\n    - Fetches match data using the API.\n    - Converts the data into a pandas DataFrame.\n    - Transforms relevant columns into JSON format.\n    - Adds a load timestamp column.\n    - Loads the final DataFrame into the database.\n\n    Example:\n        matches_processor = MatchesProcessor(api_connection=matches_api, schema='RAW', table='matches')\n        matches_processor.process()\n    \"\"\"\n    self.logger.info(f\"Start Processing - {self.table}\")\n\n    matches_data = []\n\n    self.logger.info(f'Retrieving data for matches today.')\n    match_data = MatchesTodayResponse(**self.api_connection.get_matches_today())\n    # Convertendo para dicion\u00e1rio e depois criando o DataFrame\n    matches_dict = [comp.model_dump() for comp in match_data.matches]\n    df = pd.DataFrame(matches_dict)\n    df['date_from'] = match_data.filters.date_from\n\n    matches_data.append(df)\n\n    final_matches_df = pd.concat(matches_data)\n\n    # Converte as colunas 'area' e 'current_season' para JSON (se n\u00e3o forem nulas)\n    final_matches_df['area'] = final_matches_df['area'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_matches_df['competition'] = final_matches_df['competition'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_matches_df['season'] = final_matches_df['season'].apply(lambda x: json.dumps(x, default=str) if isinstance(x, dict) else None)\n    final_matches_df['home_team'] = final_matches_df['home_team'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_matches_df['away_team'] = final_matches_df['away_team'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_matches_df['score'] = final_matches_df['score'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_matches_df['odds'] = final_matches_df['odds'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_matches_df['referees'] = final_matches_df['referees'].apply(lambda x: json.dumps([element for element in x if isinstance(element, dict)], default=str) if isinstance(x, list) else None)\n\n    load_timesamp = datetime.datetime.now(datetime.timezone.utc).isoformat() \n\n    metadata = {\n        \"load_timestamp\": [load_timesamp] * len(final_matches_df),\n    }\n\n    metadata_df = pd.DataFrame(metadata, index=final_matches_df.index)\n\n    df_with_metadata = pd.concat([final_matches_df, metadata_df], axis=1)\n\n    # df_with_metadata.to_csv('matches_today', index=False)\n    self.logger.info(f\"Writing to Database - {self.table}:\")\n    self._write_to_db(df_with_metadata)\n</code></pre>"},{"location":"extraction/matches_api/#src.utils.matches_api.MatchesProcessor._write_to_db","title":"<code>_write_to_db(df)</code>","text":"<p>Writes the processed DataFrame to the database.</p> <p>This method executes the necessary SQL queries to insert the data into the specified  database table after validating that the table exists and truncating the existing data.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to write to the database.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If there is an issue with the database connection or query execution.</p> Source code in <code>src/utils/matches_api.py</code> <pre><code>def _write_to_db(self, df: pd.DataFrame) -&gt; None:\n    \"\"\"\n    Writes the processed DataFrame to the database.\n\n    This method executes the necessary SQL queries to insert the data into the specified \n    database table after validating that the table exists and truncating the existing data.\n\n    Args:\n        df (pd.DataFrame): The DataFrame to write to the database.\n\n    Raises:\n        Exception: If there is an issue with the database connection or query execution.\n    \"\"\"\n\n    query = getattr(create_queries, self.table.upper()).format(\n        schema=self.schema,\n        table=self.table\n    )\n    # Verificar e criar a tabela se necess\u00e1rio\n    self.db.validate_table_exists(self.schema, self.table, query)\n    self.db.execute_query(\n        create_queries.TRUNCATE_TABLE.format(\n            schema=self.schema,\n            table=self.table\n        )\n    )\n    self.db.insert_pandas_bulk(df,f'{self.schema}.{self.table}')\n</code></pre>"},{"location":"extraction/matches_api/#queries","title":"Queries","text":"Create Queries - Schema <pre><code>COMPETITIONS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    area JSONB NOT NULL,\n    code VARCHAR(50),\n    type VARCHAR(50),\n    emblem VARCHAR(255),\n    plan VARCHAR(50),\n    current_season JSONB NOT NULL,\n    number_of_available_seasons INT NOT NULL,\n    last_updated TIMESTAMP NOT NULL,\n    load_timestamp TIMESTAMP NOT NULL\n);\n\"\"\"\n\nTEAMS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    area JSONB NOT NULL,\n    competition_id INTEGER NOT NULL,\n    team_id INTEGER NOT NULL,\n    name VARCHAR(255) NOT NULL,\n    short_name VARCHAR(255),\n    tla VARCHAR(255) NOT NULL,\n    crest VARCHAR(255) NOT NULL,\n    address VARCHAR(255) NOT NULL,\n    website VARCHAR(255),\n    founded FLOAT,\n    club_colors VARCHAR(255),\n    venue VARCHAR(255),\n    running_competitions JSONB,\n    coach JSONB,\n    squad JSONB,\n    staff JSONB,\n    last_updated TIMESTAMP NOT NULL,\n    load_timestamp TIMESTAMP NOT NULL,\n    UNIQUE (competition_id, team_id)\n);\n\"\"\"\n\nCOMPETITIONS_STANDINGS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    position INTEGER NOT NULL,\n    team JSONB NOT NULL,\n    played_games INTEGER NOT NULL,\n    form VARCHAR(255),\n    won INTEGER NOT NULL,\n    draw INTEGER NOT NULL,\n    lost INTEGER NOT NULL,\n    points INTEGER NOT NULL,\n    goals_for INTEGER NOT NULL,\n    goals_against INTEGER NOT NULL,\n    goal_difference INTEGER NOT NULL,\n    competition_id INTEGER NOT NULL,\n    season INTEGER NOT NULL,\n    season_info JSONB,\n    load_timestamp TIMESTAMP NOT NULL,\n    UNIQUE (competition_id, position, season)\n);\n\"\"\"\n\nCOMPETITIONS_TOP_SCORERS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    player JSONB NOT NULL,                \n    team JSONB NOT NULL,                   \n    played_matches INT,                   \n    goals INT,                            \n    assists FLOAT,                          \n    penalties FLOAT,                      \n    competition_id INT NOT NULL,          \n    season INT NOT NULL,                  \n    season_info JSONB NOT NULL,            \n    load_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,\n    UNIQUE (competition_id, season, player)\n);\n\"\"\"\n\nMATCHES_TODAY = \"\"\"\nCREATE TABLE {schema}.{table} (\n    area JSONB, \n    competition JSONB, \n    season JSONB, \n    id BIGINT PRIMARY KEY,\n    utc_date TIMESTAMP WITH TIME ZONE,\n    status VARCHAR(50),\n    matchday INT, \n    stage VARCHAR(50),\n    which_group VARCHAR(50), \n    last_updated TIMESTAMP WITH TIME ZONE,\n    home_team JSONB, \n    away_team JSONB, \n    score JSONB, \n    odds JSONB,\n    referees JSONB, \n    date_from DATE,\n    load_timestamp TIMESTAMP WITH TIME ZONE\n);\n\"\"\"\n\nTEAMS_UPCOMING_MATCHES = \"\"\"\nCREATE TABLE {schema}.{table} (\n    area JSONB, \n    competition JSONB, \n    season JSONB, \n    id BIGINT PRIMARY KEY,\n    utc_date TIMESTAMP WITH TIME ZONE,\n    status VARCHAR(50),\n    matchday INT, \n    stage VARCHAR(50),\n    which_group VARCHAR(50), \n    last_updated TIMESTAMP WITH TIME ZONE,\n    home_team JSONB, \n    away_team JSONB, \n    score JSONB, \n    odds JSONB,\n    referees JSONB, \n    date_from DATE,\n    date_to DATE,\n    load_timestamp TIMESTAMP WITH TIME ZONE\n);\n\"\"\"\n\nTRUNCATE_TABLE = \"\"\"\ntruncate table {schema}.{table};\n\"\"\"\n</code></pre>"},{"location":"extraction/teams_api/","title":"Teams","text":""},{"location":"extraction/teams_api/#workflow-processor-api","title":"Workflow (Processor + API)","text":"<pre><code>graph TD\n    A[Start]  --&gt; C[TeamsProcessor]\n    C --&gt; C1[process]\n    C1 --&gt; C2[Fetch teams data from API]\n    C2 --&gt; B[TeamsAPI]\n    B --&gt; B1[get_teams]\n    B --&gt; B2[get_team_by_id]\n    B --&gt; B3[get_team_upcoming_matches]\n    B1 --&gt; C3[Transform data using TeamsResponse]\n    B2 --&gt; C3\n    B3 --&gt; C3\n    C3 --&gt; C4[Load data into database]\n\n    A --&gt; D[TeamUpcomingMatchesProcessor]\n    D --&gt; D1[process]\n    D1 --&gt; D2[Fetch upcoming matches from API]\n    D2 --&gt; B\n    B1 --&gt; D3[Transform match data using MatchesTodayResponse]\n    B2 --&gt; D3\n    B3 --&gt; D3\n    D3 --&gt; D4[Load matches into database]\n</code></pre> TeamsAPI Class <p>               Bases: <code>FootballAPIBase</code></p> <p>Handles API interactions for fetching team-related data.</p> <p>Methods:</p> Name Description <code>- get_teams</code> <p>Fetches teams participating in a specific competition.</p> <code>- get_team_by_id</code> <p>Fetches details of a specific team.</p> <code>- get_team_upcoming_matches</code> <p>Fetches upcoming matches of a team.</p> Source code in <code>src/utils/teams_api.py</code> <pre><code>class TeamsAPI(FootballAPIBase):\n    \"\"\"\n    Handles API interactions for fetching team-related data.\n\n    Methods:\n        - get_teams: Fetches teams participating in a specific competition.\n        - get_team_by_id: Fetches details of a specific team.\n        - get_team_upcoming_matches: Fetches upcoming matches of a team.\n    \"\"\"\n    def get_teams(self, competition_id: int) -&gt; Dict[str, Any]:\n        \"\"\"\n        Fetches teams participating in a specific competition.\n\n        Args:\n            competition_id (int): The ID of the competition to fetch teams from.\n\n        Returns:\n            Dict[str, Any]: The API response containing team details.\n        \"\"\"\n        return self._make_request(f\"competitions/{competition_id}/teams\")\n\n    def get_team_by_id(self, team_id: int) -&gt; Dict[str, Any]:\n        \"\"\"\n        Fetches details of a specific team.\n\n        Args:\n            team_id (int): The ID of the team to fetch details for.\n\n        Returns:\n            Dict[str, Any]: The API response containing the team's details.\n        \"\"\"\n        return self._make_request(f\"teams/{team_id}\")\n\n    def get_team_upcoming_matches(self, team_id: int) -&gt; Dict[str, Any]:\n        \"\"\"\n        Fetches upcoming matches of a specific team.\n\n        Args:\n            team_id (int): The ID of the team to fetch matches for.\n\n        Returns:\n            Dict[str, Any]: The API response containing the team's upcoming match details.\n        \"\"\"\n        return self._make_request(f\"teams/{team_id}/matches?status=SCHEDULED&amp;limit=10\")\n</code></pre> TeamsProcessor Class <p>               Bases: <code>Processor</code></p> <p>Processes and integrates team data from the API into the database.</p> <p>Attributes:</p> Name Type Description <code>api_connection</code> <code>TeamsAPI</code> <p>API connection for fetching data.</p> <code>competition_ids</code> <code>List[int]</code> <p>List of competition IDs for processing.</p> <code>schema</code> <code>str</code> <p>Database schema name.</p> <code>table</code> <code>str</code> <p>Database table name.</p> <p>Methods:</p> Name Description <code>- process</code> <p>Fetches, transforms, and loads team data into the database.</p> <code>- _write_to_db</code> <p>Writes processed data to the database.</p> Source code in <code>src/utils/teams_api.py</code> <pre><code>class TeamsProcessor(Processor):\n    \"\"\"\n    Processes and integrates team data from the API into the database.\n\n    Attributes:\n        api_connection (TeamsAPI): API connection for fetching data.\n        competition_ids (List[int]): List of competition IDs for processing.\n        schema (str): Database schema name.\n        table (str): Database table name.\n\n    Methods:\n        - process: Fetches, transforms, and loads team data into the database.\n        - _write_to_db: Writes processed data to the database.\n    \"\"\"\n\n    def __init__(self, api_connection: TeamsAPI, competition_ids: list, schema = 'RAW', table = None):\n        \"\"\"\n        Initializes the TeamsProcessor instance.\n\n        Args:\n            api_connection (TeamsAPI): The API connection instance.\n            competition_ids (List[int]): List of competition IDs to process.\n            schema (str, optional): Database schema name. Defaults to 'RAW'.\n            table (str, optional): Database table name. Defaults to None.\n        \"\"\"\n\n        super().__init__(api_connection, self.__class__.__name__)\n\n        if schema:\n            self.schema = schema\n        if table:\n            self.table = table\n\n        self.competition_ids = competition_ids\n\n        self.db = Database(\n            db_name=os.getenv('PG_DB'),\n            user=os.getenv('PG_USER'),\n            password=os.getenv('PG_PASS'),\n            host=os.getenv('PG_HOST'),\n            port=5432\n        )\n\n    def process(self) -&gt; None:\n        \"\"\"\n        Processes team data by fetching it from the API, transforming it, \n        and loading it into the database.\n        \"\"\"\n        self.logger.info(f\"Start Processing - {self.table}\")\n\n        teams_data = []\n\n        competition_ids_result = self.db.select(table=f'{self.schema}.competitions', columns='distinct id')\n        competition_ids = [row[0] for row in competition_ids_result]\n\n        self.logger.info(f\"Competition IDs to be retrieved: {competition_ids}\")\n\n        for competition_id in competition_ids:\n            self.logger.info(f'Retrieving data for competition id: {competition_id}')\n            team_data = TeamsResponse(**self.api_connection.get_teams(competition_id))\n            # Converting into dict and then creating the Dataframe\n            teams_dict = [comp.model_dump() for comp in team_data.teams]\n            df = pd.DataFrame(teams_dict)\n            df['competition_id'] = competition_id\n\n            teams_data.append(df)\n\n        final_competition_teams_df = pd.concat(teams_data)\n\n        # Convert area and season coluns into json format (if they are not null)\n        final_competition_teams_df['area'] = final_competition_teams_df['area'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_competition_teams_df['squad'] = final_competition_teams_df['squad'].apply(lambda x: json.dumps([element for element in x if isinstance(element, dict)], default=str) if isinstance(x, list) else None)\n        final_competition_teams_df['staff'] = final_competition_teams_df['staff'].apply(lambda x: json.dumps([element for element in x if isinstance(element, dict)], default=str) if isinstance(x, list) else None)\n        final_competition_teams_df['running_competitions'] = final_competition_teams_df['running_competitions'].apply(lambda x: json.dumps([element for element in x if isinstance(element, dict)]) if isinstance(x, list) else None)\n        final_competition_teams_df['coach'] = final_competition_teams_df['coach'].apply(lambda x: json.dumps(x, default=str) if isinstance(x, dict) else None)\n        final_competition_teams_df.rename(columns={'id': 'team_id'}, inplace=True)\n\n        load_timesamp = datetime.datetime.now(datetime.timezone.utc).isoformat() \n\n        metadata = {\n            \"load_timestamp\": [load_timesamp] * len(final_competition_teams_df),\n        }\n\n        metadata_df = pd.DataFrame(metadata, index=final_competition_teams_df.index)\n\n        df_with_metadata = pd.concat([final_competition_teams_df, metadata_df], axis=1)\n\n        # Verifying the Dataframe\n        # self.logger.info(df_with_metadata)\n        self.logger.info(f\"Writing to Database - {self.table}:\")\n        self._write_to_db(df_with_metadata)\n\n    def _write_to_db(self, df: pd.DataFrame) -&gt; None:\n        \"\"\"\n        Writes the processed DataFrame to the database.\n\n        Args:\n            df (pd.DataFrame): The DataFrame to write to the database.\n        \"\"\"\n\n        query = getattr(create_queries, self.table.upper()).format(\n            schema=self.schema,\n            table=self.table\n        )\n        # Verify and create the table if necessary\n        self.db.validate_table_exists(self.schema, self.table, query)\n        self.db.execute_query(\n            create_queries.TRUNCATE_TABLE.format(\n                schema=self.schema,\n                table=self.table\n            )\n        )\n        self.db.insert_pandas_bulk(df,f'{self.schema}.{self.table}')\n</code></pre> TeamsUpcomingMatchesProcessor Class <p>               Bases: <code>Processor</code></p> <p>Processes and integrates upcoming match data for teams into the database.</p> <p>Attributes:</p> Name Type Description <code>api_connection</code> <code>TeamsAPI</code> <p>API connection for fetching match data.</p> <code>schema</code> <code>str</code> <p>Database schema name.</p> <code>table</code> <code>str</code> <p>Database table name.</p> <p>Methods:</p> Name Description <code>- process</code> <p>Fetches, transforms, and loads match data into the database.</p> Source code in <code>src/utils/teams_api.py</code> <pre><code>class TeamUpcomingMatchesProcessor(Processor):\n    \"\"\"\n    Processes and integrates upcoming match data for teams into the database.\n\n    Attributes:\n        api_connection (TeamsAPI): API connection for fetching match data.\n        schema (str): Database schema name.\n        table (str): Database table name.\n\n    Methods:\n        - process: Fetches, transforms, and loads match data into the database.\n    \"\"\"\n    def __init__(self, api_connection: TeamsAPI, schema = 'RAW', table = None):\n        \"\"\"\n        Initializes the TeamsProcessor.\n\n        Args:\n            api_connection: The API connection used for fetching data.\n            schema (str, optional): The schema to use in the database. Defaults to 'RAW'.\n            table (str, optional): The table to insert data into. Defaults to None.\n        \"\"\"\n        super().__init__(api_connection, self.__class__.__name__)\n\n        if schema:\n            self.schema = schema\n        if table:\n            self.table = table\n\n        self.db = Database(\n            db_name=os.getenv('PG_DB'),\n            user=os.getenv('PG_USER'),\n            password=os.getenv('PG_PASS'),\n            host=os.getenv('PG_HOST'),\n            port=5432\n        )\n\n    def process(self) -&gt; None:\n        \"\"\"\n        Processes team data by fetching it from the API, transforming it, \n        and loading it into the database.\n        \"\"\"\n        self.logger.info(f\"Start Processing - {self.table}\")\n\n        teams_matches_data = []\n\n        teams_ids_result = self.db.select(table=f'{self.schema}.teams', columns='distinct team_id')\n        teams_ids = [row[0] for row in teams_ids_result]\n        # teams_ids = [86]\n\n        self.logger.info(f\"Team IDs to be retrieved: {teams_ids}\")\n\n        for team_id in teams_ids:\n            self.logger.info(f'Retrieving data for team id: {team_id}')\n            team_matches_data = MatchesTodayResponse(**self.api_connection.get_team_upcoming_matches(team_id))\n            # Converting into dict and then creating the dataframe\n            teams_matches_dict = [comp.model_dump() for comp in team_matches_data.matches]\n            df = pd.DataFrame(teams_matches_dict)\n            df['date_from'] = team_matches_data.filters.date_from\n            df['date_to'] = team_matches_data.filters.date_to\n\n            teams_matches_data.append(df)\n\n        final_teams_matches_df = pd.concat(teams_matches_data)\n\n        # Convert area and season coluns into json format (if they are not null)\n        final_teams_matches_df['area'] = final_teams_matches_df['area'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_teams_matches_df['competition'] = final_teams_matches_df['competition'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_teams_matches_df['season'] = final_teams_matches_df['season'].apply(lambda x: json.dumps(x, default=str) if isinstance(x, dict) else None)\n        final_teams_matches_df['home_team'] = final_teams_matches_df['home_team'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_teams_matches_df['away_team'] = final_teams_matches_df['away_team'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_teams_matches_df['score'] = final_teams_matches_df['score'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_teams_matches_df['odds'] = final_teams_matches_df['odds'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n        final_teams_matches_df['referees'] = final_teams_matches_df['referees'].apply(lambda x: json.dumps([element for element in x if isinstance(element, dict)], default=str) if isinstance(x, list) else None)\n\n        load_timesamp = datetime.datetime.now(datetime.timezone.utc).isoformat() \n\n        metadata = {\n            \"load_timestamp\": [load_timesamp] * len(final_teams_matches_df),\n        }\n\n        metadata_df = pd.DataFrame(metadata, index=final_teams_matches_df.index)\n\n        df_with_metadata = pd.concat([final_teams_matches_df, metadata_df], axis=1)\n\n        df_with_metadata.to_csv('teams_matches', index=False)\n        self.logger.info(f\"Writing to Database - {self.table}:\")\n        self._write_to_db(df_with_metadata)\n\n    def _write_to_db(self, df: pd.DataFrame) -&gt; None:\n        \"\"\"\n        Writes the processed DataFrame to the database.\n\n        Args:\n            df (pd.DataFrame): The DataFrame to write to the database.\n        \"\"\"\n\n        query = getattr(create_queries, self.table.upper()).format(\n            schema=self.schema,\n            table=self.table\n        )\n        # Verify and create the table if necessary\n        self.db.validate_table_exists(self.schema, self.table, query)\n        self.db.execute_query(\n            create_queries.TRUNCATE_TABLE.format(\n                schema=self.schema,\n                table=self.table\n            )\n        )\n        self.db.insert_pandas_bulk(df,f'{self.schema}.{self.table}')\n</code></pre>"},{"location":"extraction/teams_api/#src.utils.teams_api.TeamsAPI.get_teams","title":"<code>get_teams(competition_id)</code>","text":"<p>Fetches teams participating in a specific competition.</p> <p>Parameters:</p> Name Type Description Default <code>competition_id</code> <code>int</code> <p>The ID of the competition to fetch teams from.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The API response containing team details.</p> Source code in <code>src/utils/teams_api.py</code> <pre><code>def get_teams(self, competition_id: int) -&gt; Dict[str, Any]:\n    \"\"\"\n    Fetches teams participating in a specific competition.\n\n    Args:\n        competition_id (int): The ID of the competition to fetch teams from.\n\n    Returns:\n        Dict[str, Any]: The API response containing team details.\n    \"\"\"\n    return self._make_request(f\"competitions/{competition_id}/teams\")\n</code></pre>"},{"location":"extraction/teams_api/#src.utils.teams_api.TeamsAPI.get_team_by_id","title":"<code>get_team_by_id(team_id)</code>","text":"<p>Fetches details of a specific team.</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>int</code> <p>The ID of the team to fetch details for.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The API response containing the team's details.</p> Source code in <code>src/utils/teams_api.py</code> <pre><code>def get_team_by_id(self, team_id: int) -&gt; Dict[str, Any]:\n    \"\"\"\n    Fetches details of a specific team.\n\n    Args:\n        team_id (int): The ID of the team to fetch details for.\n\n    Returns:\n        Dict[str, Any]: The API response containing the team's details.\n    \"\"\"\n    return self._make_request(f\"teams/{team_id}\")\n</code></pre>"},{"location":"extraction/teams_api/#src.utils.teams_api.TeamsAPI.get_team_upcoming_matches","title":"<code>get_team_upcoming_matches(team_id)</code>","text":"<p>Fetches upcoming matches of a specific team.</p> <p>Parameters:</p> Name Type Description Default <code>team_id</code> <code>int</code> <p>The ID of the team to fetch matches for.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The API response containing the team's upcoming match details.</p> Source code in <code>src/utils/teams_api.py</code> <pre><code>def get_team_upcoming_matches(self, team_id: int) -&gt; Dict[str, Any]:\n    \"\"\"\n    Fetches upcoming matches of a specific team.\n\n    Args:\n        team_id (int): The ID of the team to fetch matches for.\n\n    Returns:\n        Dict[str, Any]: The API response containing the team's upcoming match details.\n    \"\"\"\n    return self._make_request(f\"teams/{team_id}/matches?status=SCHEDULED&amp;limit=10\")\n</code></pre>"},{"location":"extraction/teams_api/#src.utils.teams_api.TeamsProcessor.__init__","title":"<code>__init__(api_connection, competition_ids, schema='RAW', table=None)</code>","text":"<p>Initializes the TeamsProcessor instance.</p> <p>Parameters:</p> Name Type Description Default <code>api_connection</code> <code>TeamsAPI</code> <p>The API connection instance.</p> required <code>competition_ids</code> <code>List[int]</code> <p>List of competition IDs to process.</p> required <code>schema</code> <code>str</code> <p>Database schema name. Defaults to 'RAW'.</p> <code>'RAW'</code> <code>table</code> <code>str</code> <p>Database table name. Defaults to None.</p> <code>None</code> Source code in <code>src/utils/teams_api.py</code> <pre><code>def __init__(self, api_connection: TeamsAPI, competition_ids: list, schema = 'RAW', table = None):\n    \"\"\"\n    Initializes the TeamsProcessor instance.\n\n    Args:\n        api_connection (TeamsAPI): The API connection instance.\n        competition_ids (List[int]): List of competition IDs to process.\n        schema (str, optional): Database schema name. Defaults to 'RAW'.\n        table (str, optional): Database table name. Defaults to None.\n    \"\"\"\n\n    super().__init__(api_connection, self.__class__.__name__)\n\n    if schema:\n        self.schema = schema\n    if table:\n        self.table = table\n\n    self.competition_ids = competition_ids\n\n    self.db = Database(\n        db_name=os.getenv('PG_DB'),\n        user=os.getenv('PG_USER'),\n        password=os.getenv('PG_PASS'),\n        host=os.getenv('PG_HOST'),\n        port=5432\n    )\n</code></pre>"},{"location":"extraction/teams_api/#src.utils.teams_api.TeamsProcessor.process","title":"<code>process()</code>","text":"<p>Processes team data by fetching it from the API, transforming it,  and loading it into the database.</p> Source code in <code>src/utils/teams_api.py</code> <pre><code>def process(self) -&gt; None:\n    \"\"\"\n    Processes team data by fetching it from the API, transforming it, \n    and loading it into the database.\n    \"\"\"\n    self.logger.info(f\"Start Processing - {self.table}\")\n\n    teams_data = []\n\n    competition_ids_result = self.db.select(table=f'{self.schema}.competitions', columns='distinct id')\n    competition_ids = [row[0] for row in competition_ids_result]\n\n    self.logger.info(f\"Competition IDs to be retrieved: {competition_ids}\")\n\n    for competition_id in competition_ids:\n        self.logger.info(f'Retrieving data for competition id: {competition_id}')\n        team_data = TeamsResponse(**self.api_connection.get_teams(competition_id))\n        # Converting into dict and then creating the Dataframe\n        teams_dict = [comp.model_dump() for comp in team_data.teams]\n        df = pd.DataFrame(teams_dict)\n        df['competition_id'] = competition_id\n\n        teams_data.append(df)\n\n    final_competition_teams_df = pd.concat(teams_data)\n\n    # Convert area and season coluns into json format (if they are not null)\n    final_competition_teams_df['area'] = final_competition_teams_df['area'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_competition_teams_df['squad'] = final_competition_teams_df['squad'].apply(lambda x: json.dumps([element for element in x if isinstance(element, dict)], default=str) if isinstance(x, list) else None)\n    final_competition_teams_df['staff'] = final_competition_teams_df['staff'].apply(lambda x: json.dumps([element for element in x if isinstance(element, dict)], default=str) if isinstance(x, list) else None)\n    final_competition_teams_df['running_competitions'] = final_competition_teams_df['running_competitions'].apply(lambda x: json.dumps([element for element in x if isinstance(element, dict)]) if isinstance(x, list) else None)\n    final_competition_teams_df['coach'] = final_competition_teams_df['coach'].apply(lambda x: json.dumps(x, default=str) if isinstance(x, dict) else None)\n    final_competition_teams_df.rename(columns={'id': 'team_id'}, inplace=True)\n\n    load_timesamp = datetime.datetime.now(datetime.timezone.utc).isoformat() \n\n    metadata = {\n        \"load_timestamp\": [load_timesamp] * len(final_competition_teams_df),\n    }\n\n    metadata_df = pd.DataFrame(metadata, index=final_competition_teams_df.index)\n\n    df_with_metadata = pd.concat([final_competition_teams_df, metadata_df], axis=1)\n\n    # Verifying the Dataframe\n    # self.logger.info(df_with_metadata)\n    self.logger.info(f\"Writing to Database - {self.table}:\")\n    self._write_to_db(df_with_metadata)\n</code></pre>"},{"location":"extraction/teams_api/#src.utils.teams_api.TeamsProcessor._write_to_db","title":"<code>_write_to_db(df)</code>","text":"<p>Writes the processed DataFrame to the database.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to write to the database.</p> required Source code in <code>src/utils/teams_api.py</code> <pre><code>def _write_to_db(self, df: pd.DataFrame) -&gt; None:\n    \"\"\"\n    Writes the processed DataFrame to the database.\n\n    Args:\n        df (pd.DataFrame): The DataFrame to write to the database.\n    \"\"\"\n\n    query = getattr(create_queries, self.table.upper()).format(\n        schema=self.schema,\n        table=self.table\n    )\n    # Verify and create the table if necessary\n    self.db.validate_table_exists(self.schema, self.table, query)\n    self.db.execute_query(\n        create_queries.TRUNCATE_TABLE.format(\n            schema=self.schema,\n            table=self.table\n        )\n    )\n    self.db.insert_pandas_bulk(df,f'{self.schema}.{self.table}')\n</code></pre>"},{"location":"extraction/teams_api/#src.utils.teams_api.TeamUpcomingMatchesProcessor.__init__","title":"<code>__init__(api_connection, schema='RAW', table=None)</code>","text":"<p>Initializes the TeamsProcessor.</p> <p>Parameters:</p> Name Type Description Default <code>api_connection</code> <code>TeamsAPI</code> <p>The API connection used for fetching data.</p> required <code>schema</code> <code>str</code> <p>The schema to use in the database. Defaults to 'RAW'.</p> <code>'RAW'</code> <code>table</code> <code>str</code> <p>The table to insert data into. Defaults to None.</p> <code>None</code> Source code in <code>src/utils/teams_api.py</code> <pre><code>def __init__(self, api_connection: TeamsAPI, schema = 'RAW', table = None):\n    \"\"\"\n    Initializes the TeamsProcessor.\n\n    Args:\n        api_connection: The API connection used for fetching data.\n        schema (str, optional): The schema to use in the database. Defaults to 'RAW'.\n        table (str, optional): The table to insert data into. Defaults to None.\n    \"\"\"\n    super().__init__(api_connection, self.__class__.__name__)\n\n    if schema:\n        self.schema = schema\n    if table:\n        self.table = table\n\n    self.db = Database(\n        db_name=os.getenv('PG_DB'),\n        user=os.getenv('PG_USER'),\n        password=os.getenv('PG_PASS'),\n        host=os.getenv('PG_HOST'),\n        port=5432\n    )\n</code></pre>"},{"location":"extraction/teams_api/#src.utils.teams_api.TeamUpcomingMatchesProcessor.process","title":"<code>process()</code>","text":"<p>Processes team data by fetching it from the API, transforming it,  and loading it into the database.</p> Source code in <code>src/utils/teams_api.py</code> <pre><code>def process(self) -&gt; None:\n    \"\"\"\n    Processes team data by fetching it from the API, transforming it, \n    and loading it into the database.\n    \"\"\"\n    self.logger.info(f\"Start Processing - {self.table}\")\n\n    teams_matches_data = []\n\n    teams_ids_result = self.db.select(table=f'{self.schema}.teams', columns='distinct team_id')\n    teams_ids = [row[0] for row in teams_ids_result]\n    # teams_ids = [86]\n\n    self.logger.info(f\"Team IDs to be retrieved: {teams_ids}\")\n\n    for team_id in teams_ids:\n        self.logger.info(f'Retrieving data for team id: {team_id}')\n        team_matches_data = MatchesTodayResponse(**self.api_connection.get_team_upcoming_matches(team_id))\n        # Converting into dict and then creating the dataframe\n        teams_matches_dict = [comp.model_dump() for comp in team_matches_data.matches]\n        df = pd.DataFrame(teams_matches_dict)\n        df['date_from'] = team_matches_data.filters.date_from\n        df['date_to'] = team_matches_data.filters.date_to\n\n        teams_matches_data.append(df)\n\n    final_teams_matches_df = pd.concat(teams_matches_data)\n\n    # Convert area and season coluns into json format (if they are not null)\n    final_teams_matches_df['area'] = final_teams_matches_df['area'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_teams_matches_df['competition'] = final_teams_matches_df['competition'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_teams_matches_df['season'] = final_teams_matches_df['season'].apply(lambda x: json.dumps(x, default=str) if isinstance(x, dict) else None)\n    final_teams_matches_df['home_team'] = final_teams_matches_df['home_team'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_teams_matches_df['away_team'] = final_teams_matches_df['away_team'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_teams_matches_df['score'] = final_teams_matches_df['score'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_teams_matches_df['odds'] = final_teams_matches_df['odds'].apply(lambda x: json.dumps(x) if isinstance(x, dict) else None)\n    final_teams_matches_df['referees'] = final_teams_matches_df['referees'].apply(lambda x: json.dumps([element for element in x if isinstance(element, dict)], default=str) if isinstance(x, list) else None)\n\n    load_timesamp = datetime.datetime.now(datetime.timezone.utc).isoformat() \n\n    metadata = {\n        \"load_timestamp\": [load_timesamp] * len(final_teams_matches_df),\n    }\n\n    metadata_df = pd.DataFrame(metadata, index=final_teams_matches_df.index)\n\n    df_with_metadata = pd.concat([final_teams_matches_df, metadata_df], axis=1)\n\n    df_with_metadata.to_csv('teams_matches', index=False)\n    self.logger.info(f\"Writing to Database - {self.table}:\")\n    self._write_to_db(df_with_metadata)\n</code></pre>"},{"location":"extraction/teams_api/#src.utils.teams_api.TeamUpcomingMatchesProcessor._write_to_db","title":"<code>_write_to_db(df)</code>","text":"<p>Writes the processed DataFrame to the database.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to write to the database.</p> required Source code in <code>src/utils/teams_api.py</code> <pre><code>def _write_to_db(self, df: pd.DataFrame) -&gt; None:\n    \"\"\"\n    Writes the processed DataFrame to the database.\n\n    Args:\n        df (pd.DataFrame): The DataFrame to write to the database.\n    \"\"\"\n\n    query = getattr(create_queries, self.table.upper()).format(\n        schema=self.schema,\n        table=self.table\n    )\n    # Verify and create the table if necessary\n    self.db.validate_table_exists(self.schema, self.table, query)\n    self.db.execute_query(\n        create_queries.TRUNCATE_TABLE.format(\n            schema=self.schema,\n            table=self.table\n        )\n    )\n    self.db.insert_pandas_bulk(df,f'{self.schema}.{self.table}')\n</code></pre>"},{"location":"extraction/teams_api/#queries","title":"Queries","text":"Create Queries - Schema <pre><code>COMPETITIONS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    area JSONB NOT NULL,\n    code VARCHAR(50),\n    type VARCHAR(50),\n    emblem VARCHAR(255),\n    plan VARCHAR(50),\n    current_season JSONB NOT NULL,\n    number_of_available_seasons INT NOT NULL,\n    last_updated TIMESTAMP NOT NULL,\n    load_timestamp TIMESTAMP NOT NULL\n);\n\"\"\"\n\nTEAMS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    area JSONB NOT NULL,\n    competition_id INTEGER NOT NULL,\n    team_id INTEGER NOT NULL,\n    name VARCHAR(255) NOT NULL,\n    short_name VARCHAR(255),\n    tla VARCHAR(255) NOT NULL,\n    crest VARCHAR(255) NOT NULL,\n    address VARCHAR(255) NOT NULL,\n    website VARCHAR(255),\n    founded FLOAT,\n    club_colors VARCHAR(255),\n    venue VARCHAR(255),\n    running_competitions JSONB,\n    coach JSONB,\n    squad JSONB,\n    staff JSONB,\n    last_updated TIMESTAMP NOT NULL,\n    load_timestamp TIMESTAMP NOT NULL,\n    UNIQUE (competition_id, team_id)\n);\n\"\"\"\n\nCOMPETITIONS_STANDINGS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    position INTEGER NOT NULL,\n    team JSONB NOT NULL,\n    played_games INTEGER NOT NULL,\n    form VARCHAR(255),\n    won INTEGER NOT NULL,\n    draw INTEGER NOT NULL,\n    lost INTEGER NOT NULL,\n    points INTEGER NOT NULL,\n    goals_for INTEGER NOT NULL,\n    goals_against INTEGER NOT NULL,\n    goal_difference INTEGER NOT NULL,\n    competition_id INTEGER NOT NULL,\n    season INTEGER NOT NULL,\n    season_info JSONB,\n    load_timestamp TIMESTAMP NOT NULL,\n    UNIQUE (competition_id, position, season)\n);\n\"\"\"\n\nCOMPETITIONS_TOP_SCORERS = \"\"\"\nCREATE TABLE {schema}.{table} (\n    id SERIAL PRIMARY KEY,\n    player JSONB NOT NULL,                \n    team JSONB NOT NULL,                   \n    played_matches INT,                   \n    goals INT,                            \n    assists FLOAT,                          \n    penalties FLOAT,                      \n    competition_id INT NOT NULL,          \n    season INT NOT NULL,                  \n    season_info JSONB NOT NULL,            \n    load_timestamp TIMESTAMP WITH TIME ZONE NOT NULL,\n    UNIQUE (competition_id, season, player)\n);\n\"\"\"\n\nMATCHES_TODAY = \"\"\"\nCREATE TABLE {schema}.{table} (\n    area JSONB, \n    competition JSONB, \n    season JSONB, \n    id BIGINT PRIMARY KEY,\n    utc_date TIMESTAMP WITH TIME ZONE,\n    status VARCHAR(50),\n    matchday INT, \n    stage VARCHAR(50),\n    which_group VARCHAR(50), \n    last_updated TIMESTAMP WITH TIME ZONE,\n    home_team JSONB, \n    away_team JSONB, \n    score JSONB, \n    odds JSONB,\n    referees JSONB, \n    date_from DATE,\n    load_timestamp TIMESTAMP WITH TIME ZONE\n);\n\"\"\"\n\nTEAMS_UPCOMING_MATCHES = \"\"\"\nCREATE TABLE {schema}.{table} (\n    area JSONB, \n    competition JSONB, \n    season JSONB, \n    id BIGINT PRIMARY KEY,\n    utc_date TIMESTAMP WITH TIME ZONE,\n    status VARCHAR(50),\n    matchday INT, \n    stage VARCHAR(50),\n    which_group VARCHAR(50), \n    last_updated TIMESTAMP WITH TIME ZONE,\n    home_team JSONB, \n    away_team JSONB, \n    score JSONB, \n    odds JSONB,\n    referees JSONB, \n    date_from DATE,\n    date_to DATE,\n    load_timestamp TIMESTAMP WITH TIME ZONE\n);\n\"\"\"\n\nTRUNCATE_TABLE = \"\"\"\ntruncate table {schema}.{table};\n\"\"\"\n</code></pre>"}]}